                                                                                    1. MULTITHREADING(Thread in c++11)



1.In every application there is a default thread which is main(), inside this we create another threads.
2.Thread is a lightweight process. Idea of thread is to achieve parallesim by dividing process into multiple threads.



.................................................................................................................................................................................................................
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------



                                                                           2.WAYS TO CREATE THREAD IN C++11:

1.Function pointers
2.Lambda functions
3.Functors(objects)
4.non-static Member functions
5.Static member functions
6.using async









Eg:print odd and even numbers without using thread
#include<iostream>
#include<thread>
using namespace std;
void oddNums(int start,int end)
{
    for(int i=start;i<=end;i++)
    {
        if(i%2!=0)
        {
            cout<<i<<endl;
        }
    }
}
void evenNums(int start,int end)
{
    for(int i=start;i<=end;i++)
    {
        if(i%2==0)
        {
            cout<<i<<endl;
        }
    }
}
int main()
{
    oddNums(1,10);
    evenNums(1,10);
    return 0;
}

o/p:
1
3
5
7
9
2
4
6
8
10




Eg1:print odd and even numbers  using thread(using function pointer)
#include<iostream>
#include<thread>
using namespace std;
void oddNums(int start,int end)
{
    for(int i=start;i<=end;i++)
    {
        if(i%2!=0)
        {
            cout<<i<<endl;
        }
    }
}
void evenNums(int start,int end)
{
    for(int i=start;i<=end;i++)
    {
        if(i%2==0)
        {
            cout<<i<<endl;
        }
    }
}
int main()
{
    thread t1(oddNums,1,10);
    thread t2(evenNums,2,10);
    t1.join();
    t2.join();

    return 0;
}
o/p:
1
2
3
4
5
6
7
8
9
10




Eg3: using functor(objects)

   Eg:
    #include <iostream>
    #include <thread>

    class MyThread {
    public:
        void operator()() {
            std::cout << "Hello from thread!\n";
        }
    };

    int main() {
        std::thread t{MyThread()};
        t.join();
        return 0;
    }
    o/p:Hello from thread!




    Eg2:using Lambda

    #include <iostream>
    #include <thread>
    using namespace std;


    int main() {
        std::thread t([](){cout<<"Hello from thread";});
        t.join();
        return 0;
    }
    o/p:Hello from thread


Eg4: using non-static member function
Eg:
    #include <iostream>
    #include <thread>
    using namespace std;
    class Myclass
    {
        public:
        void func(string s)
        {
            cout<<"Hello from thread! "<<s<<endl;
        }
    };

    int main() {
        Myclass obj;
    std::thread t(&Myclass::func,&obj,"sivakrishnateja");
        t.join();
        return 0;
    }
    o/p:Hello from thread! sivakrishnateja




Eg6: using Async

Eg:
    #include <iostream>
    #include <thread>
    #include<future>
    using namespace std;
    int func()
    {
        return 102;
    }

    int main() {
        future<int>f=async(launch::async,func);
        cout<<"Inside main func"<<endl;
        cout<<"Result :"<<f.get();
        return 0;
    }

    o/p:Inside main func
        Result :102


Eg5: using static member functions


 #include <iostream>
    #include <thread>
    using namespace std;
    class Myclass
    {
        public:
        static void func(string s)
        {
            cout<<"Hello from thread! "<<s<<endl;
        }
    };

    int main() {
        
    std::thread t(&Myclass::func,"sivakrishnateja");
        t.join();
        return 0;
    }
    o/p:Hello from thread! sivakrishnateja


-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

                                                                3.JOIN AND DETACH IN C++



JOIN Notes:
    1.Once a created is started we wait for this thread to finish by calling join() function  on thread object. 
    2.Double join will result into program termination.
    3.If needed we should check thread is joinable before joining(using joinable() function).











Eg:
#include<bits/stdc++.h>
using namespace std;
void run(int x)
{
    while(x >=1)
    {
        cout<<endl<<x<<" Teja"<<endl;
        x--;
        this_thread::sleep_for(chrono::seconds(3)); //it will take 3 seconds after that only "After main" will execute
    }
}
int main()
{
thread t(run,5);
cout<<"Main"<<endl;
t.join();
cout<<"After main\n";
}

o/p:

Main
5 Teja
4 Teja
3 Teja
2 Teja
1 Teja
After main





Eg2:
#include<bits/stdc++.h>
using namespace std;
void run(int x)
{
    while(x-- >0)
    {
        cout<<endl<<x<<" Teja"<<endl;
        
        this_thread::sleep_for(chrono::seconds(3));
    }
}
int main()
{
thread t(run,10);
cout<<"Main"<<endl;
t.join();
t.join();
cout<<"After main\n";
}
o/p:
Main
9 Teja
8 Teja
7 Teja
6 Teja
5 Teja
4 Teja
3 Teja
2 Teja
1 Teja
0 Teja
terminate called after throwing an instance of 'std::system_error'
  what():  Invalid argument
Aborted (core dumped)




Eg3:
#include<bits/stdc++.h>
using namespace std;
void run(int x)
{
    while(x-- >0)
    {
        cout<<endl<<x<<" Teja"<<endl;
        
        this_thread::sleep_for(chrono::seconds(3));
    }
}
int main()
{
thread t(run,10);
cout<<"Main"<<endl;
t.join();
cout<<"Hii from inside main\n";
if(t.joinable()) //It it is already join,then only it will
t.join();
cout<<"After main\n";
}

o/p:
Main
9 Teja
8 Teja
7 Teja
6 Teja
5 Teja
4 Teja
3 Teja
2 Teja
1 Teja
0 Teja
Hii from inside main
After main




DETACH Notes:
    1.This is used to detach newly created thread from the parent thread.
    2.Always check before detaching thread  that it is joinable otherwise we may end up double detaching and double detach()  will result into program termination.
    3.If we have detached thread and main function is returning then the detaced h thread execution is suspension.


Eg1:
#include<bits/stdc++.h>
using namespace std;
void run(int x)
{
    while(x-- >0)
    {
        cout<<endl<<x<<" Teja"<<endl;
        
        this_thread::sleep_for(chrono::seconds(2));
    }
}
int main()
{
thread t(run,10);
cout<<"Main"<<endl;
t.detach();

cout<<"After main\n";
}

Note: the output behaviour was different every time.
o/p 1:
Main
After main
9 Teja
8 Teja
7 Teja
6 Teja
5 Teja
4 Teja
3 Teja
2 Teja
1 Teja
0 Teja

o/p 2:
Main
After main



Eg2:
#include<bits/stdc++.h>
using namespace std;
void run(int x)
{
    while(x-- >0)
    {
        cout<<endl<<x<<" Teja"<<endl;
        
        this_thread::sleep_for(chrono::seconds(2));
    }
}
int main()
{
thread t(run,10);
cout<<"Main"<<endl;
t.detach();
if(t.joinable())
t.detach();

cout<<"After main\n";
}





-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

                                                                                4.MUTEX IN C++




* Mutex in c++ Threading  | Why use Mutex | What is Race condition  and how to solve it ? | what is critical section


1. What is mutex ?
    *Mutex stans for mutual exclusion.
    *It can be accessing something mutually ,first you and next follows.


2.why mutex is used?
    *Mutex is used to avoid race condition.
    *we use lock() unlock() on mutex to avoid race condition.


3.Race condition:
    *Race condition is a situation,where two or more threads process happend to change a common data at same time.


4. Critical section:
    *If there is a race condition then we have to protect it and the protected section is called critical section.
















   
    



