MULTITHREADING(Thread in c++11):
-------------------------------
1.In every application there is a default thread which is main(), inside this we create another threads.
2.Thread is a lightweight process. Idea of thread is to achieve parallesim by dividing process into multiple threads.


WAYS TO CREATE THREAD IN C++11:
--------------------------------
1.Function pointers
2.Lambda functions
3.Functors
4.Member functions
5.Static member functions









Eg:print odd and even numbers without using thread
#include<iostream>
#include<thread>
using namespace std;
void oddNums(int start,int end)
{
    for(int i=start;i<=end;i++)
    {
        if(i%2!=0)
        {
            cout<<i<<endl;
        }
    }
}
void evenNums(int start,int end)
{
    for(int i=start;i<=end;i++)
    {
        if(i%2==0)
        {
            cout<<i<<endl;
        }
    }
}
int main()
{
    oddNums(1,10);
    evenNums(1,10);
    return 0;
}

o/p:
1
3
5
7
9
2
4
6
8
10




Eg:print odd and even numbers  using thread(using function pointer)
#include<iostream>
#include<thread>
using namespace std;
void oddNums(int start,int end)
{
    for(int i=start;i<=end;i++)
    {
        if(i%2!=0)
        {
            cout<<i<<endl;
        }
    }
}
void evenNums(int start,int end)
{
    for(int i=start;i<=end;i++)
    {
        if(i%2==0)
        {
            cout<<i<<endl;
        }
    }
}
int main()
{
    thread t1(oddNums,1,10);
    thread t2(evenNums,2,10);
    t1.join();
    t2.join();

    return 0;
}
o/p:
1
2
3
4
5
6
7
8
9
10
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
The threads library was introduced in the C++11 standard, which was released in 2011. The motivation to add threads in C++ was to provide a standardized, portable, and efficient way to write concurrent programs in C++. Prior to the C++11 standard, the C++ language did not provide a standard way to create and manage threads, and developers had to rely on platform-specific APIs such as POSIX threads or Windows threads. This made it difficult to write portable and maintainable concurrent code. With the addition of the thread library to the C++ standard, developers can now write portable and standardized multithreaded code that can run on any platform that supports the C++ standard library.
Additionally, the rise of multicore processors made multithreaded programming an important technique for improving the performance of software applications. The addition of the thread library to C++ provides developers with a powerful tool for writing efficient and scalable multithreaded code that can take advantage of the increased processing power of modern CPUs.



*How to create thread in C++ std?
    There are several ways to create threads in C++ using the standard library.

    Let me list down few of them here:

    1.Using the function std::thread constructor: This is the most common way to create threads in C++. You can pass a function or a lambda expression to the constructor, and a new thread will be created that will execute that function or lambda expression.
     ------------------------------------------
    Eg:
    #include<iostream>
    #include <thread>

    void my_thread_function(int* pData)
    {
        std::cout << "Hello from my_thread_function! 
        and data passd ="<<*pData << std::endl;
    }

    int main()
    {
        int data = 101;
        std::thread my_thread(my_thread_function,&data);
        my_thread.join();
        return 0;
    }
     O/P - Hello from my_thread_function! and data passd =101


    2. USING FUNCTOR: In C++, a functor is an object that can be treated like a function or a function pointer. Functors are also known as function objects, as they encapsulate a function or a code block within an object, which can be called like a regular function.
      --------------
        Functors are often used in C++ to provide a more flexible and object-oriented way of calling functions. They can be used to provide additional state or context to a function, which can be helpful in some cases, such as when working with algorithms that require a comparison function or when implementing callbacks and of course in this case thread creation.
        To create a functor in C++, you define a class with an overloaded operator() function. This allows instances of the class to be called like a regular function.



    Eg:
    #include <iostream>
    #include <thread>

    class MyThread {
    public:
        void operator()() {
            std::cout << "Hello from thread!\n";
        }
    };

    int main() {
        std::thread t{MyThread()};
        t.join();
        return 0;
    }
    o/p:Hello from thread!


    3.USING aA LAMBDA FUNCTION:
     --------------------------
    Allows you to define an anonymous function on the fly. It is a shorthand way of defining a function object (a functor) without having to define a separate class or function for it. Lambda functions can be used wherever a function object is required, such as in STL algorithms, for callbacks, threads or for creating closures. Lambda functions can capture variables from their enclosing scope by value or by reference and can have parameters and a return value.

    Eg:
    #include <iostream>
    #include <thread>
    using namespace std;


    int main() {
        std::thread t([](){cout<<"Hello from thread";});
        t.join();
        return 0;
    }
    o/p:Hello from thread

    4.USING MEMBER FUNCTION AND OBJECT:
      --------------------------------In the below example of creating a thread using a member function and an object, &my_object is passed as the second parameter to std::thread() because we need to provide the instance of the class on which the member function should be called.
    When we pass a member function to the std::thread() constructor, we also need to provide the object on which that function should be called. The second parameter to the std::thread() constructor is a pointer to the object on which the member function should be called.

    Eg:
    #include <iostream>
    #include <thread>
    using namespace std;
    class Myclass
    {
        public:
        void func(string s)
        {
            cout<<"Hello from thread! "<<s<<endl;
        }
    };

    int main() {
        Myclass obj;
    std::thread t(&Myclass::func,&obj,"sivakrishnateja");
        t.join();
        return 0;
    }
    o/p:Hello from thread! sivakrishnateja


    5.USING AN ASYNC FUNCTION:
     ------------------------ Using the function async: This function creates a new thread and returns a future object that can be used to retrieve the result of the thread's execution.

    Eg:
    #include <iostream>
    #include <thread>
    #include<future>
    using namespace std;
    int func()
    {
        return 102;
    }

    int main() {
        future<int>f=async(launch::async,func);
        cout<<"Inside main func"<<endl;
        cout<<"Result :"<<f.get();
        return 0;
    }

    o/p:Inside main func
        Result :102
